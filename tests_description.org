#+title: Libft tests description
* Mandatory part
** ft_isalnum
#+begin_src C
int ft_isalnum(int c);
#+end_src
** ft_isalpha
#+begin_src C
int ft_isalpha(int c);
#+end_src
** ft_isascii
#+begin_src C
int ft_isascii(int c);
#+end_src
** ft_isdigit
#+begin_src C
int ft_isdigit(int c);
#+end_src
** ft_isprint
#+begin_src C
int ft_isprint(int c);
#+end_src
** ft_strlen
#+begin_src C
size_t ft_strlen(const char *s);
#+end_src
** ft_memset
#+begin_src C
void    *ft_memset(void *s, int c, size_t n);
#+end_src
** ft_bzero
#+begin_src C
void    ft_bzero(void *s, size_t n);
#+end_src
** ft_memcpy
#+begin_src C
void    *ft_memcpy(void *dest, const void *src, size_t n);
#+end_src
*** Basic input
Basic use of the function.
*** Smaller n
Normal input but with n < strlen(input).
*** n = 0
Normal input but with n = 0.
*** destination & source the same
dst & src pointing on same address.
*** NULL destination
dst set to NULL.
Behavior on ubuntu: segfault.
*** NULL source
src set to NULL.
Behavior on ubuntu: segfault.
*** Both destination & source NULL
dst & src set to NULL.
Behavior on ubuntu: segfault.
** ft_memmove
#+begin_src C
void    *ft_memmove(void *dest, const void *src, size_t n);
#+end_src
*** Basic input
Basic use of the function.
*** destination & source the same
dst & src pointing on same address.
*** Overlapping : destination lower than source
dst address set to a lower address than src but with an overlapping size.
*** Overlapping : source lower than destination
src address set to a lower address than dst but with an overlapping size.
*** Smaller n
Normal input but with n < strlen(input).
*** n = 0
Normal input but with n = 0.
*** NULL destination
dst set to NULL.
Behavior on ubuntu: segfault.
*** NULL source
src set to NULL.
Behavior on ubuntu: segfault.
*** Both destination & source NULL
dst & src set to NULL.
Behavior on ubuntu: segfault.

** DONE ft_strlcpy [10/10]
#+begin_src C
size_t  ft_strlcpy(char *dst, const char *src, size_t size);
#+end_src
CLOSED: [2023-11-09 jeu. 09:27]
*** CODED Basic input
CLOSED: [2023-11-09 jeu. 08:21]
Basic use of the function.
Behavior: copies size-1 bytes from src to dst + \0.
Return value: length of src.
*** CODED Smaller size
CLOSED: [2023-11-09 jeu. 08:26]
Size smaller than src.
Behavior: copies size-1 bytes from src to dst + \0.
Return value: length of src.
*** CODED Bigger size
CLOSED: [2023-11-09 jeu. 08:28]
Size bigger than src.
Behavior: copies only strlen(src) bytes from src to dst.
Return value: length of src.
*** CODED Size zero
CLOSED: [2023-11-09 jeu. 08:32]
size = 0.
Behavior: doesn't copy anything.
Return value: length of src.
*** CODED dst overlapping src
CLOSED: [2023-11-09 jeu. 09:16]
dst address set to a lower adress than src but with an overlapping size.
Behavior: copies size-1 bytes from src to dst + \0.
Return value: length of src (after the copy).
*** CODED src overlapping dst
CLOSED: [2023-11-09 jeu. 09:19]
src address set to a lower adress than dst but with an overlapping size.
Behavior: copies size-1 bytes from src to dst + \0.
Return value: length of src (after the copy).
*** CODED NULL dst
CLOSED: [2023-11-09 jeu. 09:22]
dst set to NULL.
Behavior: SEGFAULT.
*** CODED NULL src
CLOSED: [2023-11-09 jeu. 09:27]
src set to NULL.
Behavior: SEGFAULT.
*** CODED NULL dst & src
CLOSED: [2023-11-09 jeu. 09:25]
dst & src set to NULL.
Behavior: SEGFAULT.

** DONE ft_strlcat [9/9]
#+begin_src C
size_t  ft_strlcat(char *dst, const char *src, size_t size);
#+end_src
CLOSED: [2023-11-12 dim. 19:18]
*** CODED Basic input
CLOSED: [2023-11-12 dim. 19:01]
Basic use of function.
Behavior: Copies size - len(dst) - 1 bytes from src to end of dst + \0.
Return value: Initial length of dst + length of src.
*** CODED Smaller size
CLOSED: [2023-11-12 dim. 19:02]
Size smaller than final buffer.
Behavior: Copies size - len(dst) - 1 bytes from src to end of dst + \0 (Truncation).
Return value: *Initial length of dst + length of src if size >= len(dst) else size + length of src.*
*** CODED Smaller small size
CLOSED: [2023-11-12 dim. 19:05]
Size smaller than len(dst).
Behavior: Doesn't copy anything.
Return value: *size + length of src.*
*** CODED Bigger size
CLOSED: [2023-11-12 dim. 19:07]
Size bigger than final buffer.
Behavior: Does the copy but stops at \0 of src.
Return value: Initial length of dst + length of src.
*** CODED Size zero
CLOSED: [2023-11-12 dim. 19:08]
Size = 0.
Behavior: Doesn't copy anything.
Return value: Length of src (same calculation than if size < len(dst)).
*** CODED NULL dst
CLOSED: [2023-11-12 dim. 19:18]
dst set to NULL.
Behavior: SEGFAULT.
Return value: /
*** CODED NULL dst & size zero
CLOSED: [2023-11-12 dim. 19:18]
dst set to NULL and size set to zero.
Behavior: Doesn't copy anything. (NO SEGFAULT).
Return value: length of src.
*** CODED NULL src
CLOSED: [2023-11-12 dim. 19:18]
src set to NULL.
Behavior: SEGFAULT.
Return value: /
*** CODED NULL dst & src
CLOSED: [2023-11-12 dim. 19:18]
dst & src set to NULL.
Behavior: SEGFAULT.
Return value: /
** DONE ft_toupper
#+begin_src C
int ft_toupper(int c);
#+end_src
CLOSED: [2023-11-13 lun. 11:34]
*** CODED basic inputs (all unsigned char)
CLOSED: [2023-11-13 lun. 11:33]
** DONE ft_tolower
#+begin_src C
int ft_tolower(int c);
#+end_src
CLOSED: [2023-11-13 lun. 11:34]
*** CODED basic inputs (all unsigned char)
CLOSED: [2023-11-13 lun. 11:33]
** DONE ft_strchr
CLOSED: [2023-11-13 lun. 13:17]
*** CODED Basic inputs (c in s)
CLOSED: [2023-11-13 lun. 12:09]
*** CODED multiple c in s
CLOSED: [2023-11-13 lun. 12:09]
*** CODED no c in s
CLOSED: [2023-11-13 lun. 12:09]
*** CODED c set to '\0'
CLOSED: [2023-11-13 lun. 12:09]
*** CODED s set to NULL
CLOSED: [2023-11-13 lun. 12:09]
** DONE ft_strrchr
CLOSED: [2023-11-13 lun. 13:17]
*** CODED Basic inputs (c in s)
CLOSED: [2023-11-13 lun. 12:12]
*** CODED multiple c in s
CLOSED: [2023-11-13 lun. 12:13]
*** CODED no c in s
CLOSED: [2023-11-13 lun. 12:13]
*** CODED c set to '\0'
CLOSED: [2023-11-13 lun. 12:13]
*** CODED s set to NULL
CLOSED: [2023-11-13 lun. 12:13]
** DONE ft_strncmp [13/13]
#+begin_src C
int ft_strncmp(const char *s1, const char *s2, size_t n);
#+end_src
CLOSED: [2023-11-13 lun. 15:03]
*** CODED Basic inputs s1 == s2
CLOSED: [2023-11-13 lun. 13:41]
s1 & s2 the same.
Return value: 0
*** CODED Basic inputs s1 != s2, n = len(s1) (s1 < s2)
CLOSED: [2023-11-13 lun. 13:46]
s1 & s2 different, s1 less than s2
Return value: negative (s1[i] - s2[i])
*** CODED Basic inputs s1 != s2, n = len(s1) (s1 > s2)
CLOSED: [2023-11-13 lun. 13:46]
s1 & s2 different, s1 greater than s2
Return value: positive (s1[i] - s2[i])
*** CODED len s1 < len s2
CLOSED: [2023-11-13 lun. 13:48]
s1 & s2 the same until '\0' in s1. n set to length of s2.
Return value: negative (0 - s2[i])
*** CODED len s1 > len s2
CLOSED: [2023-11-13 lun. 13:49]
s1 & s2 the same until '\0' in s2. n set to length of s1.
Return value: positive (s1[i] - 0)
*** CODED Smaller n
CLOSED: [2023-11-13 lun. 13:51]
n smaller than the 2 lengths.
Return value: difference between n^{th} char of the 2 strings.
*** CODED Bigger n
CLOSED: [2023-11-13 lun. 13:51]
n bigger than the 2 lengths.
Return value: difference between last char of the smaller string and equivalent char of the other.
*** CODED n = 0
CLOSED: [2023-11-13 lun. 13:52]
n set to zero.
Return value: 0
*** CODED not unsigned char inside strings
CLOSED: [2023-11-13 lun. 15:02]
Insertion of values not initially unsigned char to test that the function casts to unsigned char.
Return value: diff as usual.
*** CODED NULL s1, n > 0
CLOSED: [2023-11-13 lun. 13:55]
s1 set to NULL with n > 0.
Return value: / (SEGFAULT)
*** CODED NULL s2, n > 0
CLOSED: [2023-11-13 lun. 13:59]
s2 set to NULL with n > 0.
Return value: / (SEGFAULT)
*** CODED NULL s1 & s2, n > 0
CLOSED: [2023-11-13 lun. 13:57]
s1 & s2 set to NULL with n > 0.
Return value: / (SEGFAULT)
*** CODED NULL s1 & s2, n = 0
CLOSED: [2023-11-13 lun. 13:57]
s1 & s2 set to NULL with n > 0.
Return value: 0 (NO SEGFAULT)
** DONE ft_memchr [8/8]
#+begin_src C
void    *ft_memchr(const void *s, int c, size_t n);
#+end_src
CLOSED: [2023-11-13 lun. 16:12]
*** CODED Basic with c in s
CLOSED: [2023-11-13 lun. 15:46]
Normal use of the function with c placed in s.
Return value: pointer to first instance of c in s.
*** CODED multiple c in s
CLOSED: [2023-11-13 lun. 15:47]
Normal use of the function, c has multiple instances in s.
Return value: pointer to first instance of c in s.
*** CODED c not in s
CLOSED: [2023-11-13 lun. 15:48]
Normal use of the function, c not in s.
Return value: NULL.
*** CODED c not unsigned char
CLOSED: [2023-11-13 lun. 15:49]
Test the function with a non unsigned char value in c (present in s).
Return value: pointer to instance of c in s (only if c and s[i] are cast to unsigned char).
*** CODED c set to '\0'
CLOSED: [2023-11-13 lun. 15:51]
Search for '\0' ('\0' is also put in s).
Return value: pointer to '\0' in s.
*** CODED Smaller n
CLOSED: [2023-11-13 lun. 15:52]
Normal inputs but n smaller than s.
Return value: pointer to first instance of c but tests at most n bytes.
*** CODED s set to NULL with n > 0
CLOSED: [2023-11-13 lun. 15:55]
s set to NULL.
Return value: / (SEGFAULT).
*** CODED s set to NULL with n = 0
CLOSED: [2023-11-13 lun. 15:56]
s set to NULL and n to zero.
Return value: NULL.
** DONE ft_memcmp [11/11]
#+begin_src C
int ft_memcmp(const void *s1, const void *s2, size_t n);
#+end_src
CLOSED: [2023-11-13 lun. 17:33]
*** CODED Basic, s1 == s2
CLOSED: [2023-11-13 lun. 17:16]
Basic use of the function, s1 and s2 beeing equal and n = len(s1).
Return value: 0.
*** CODED Basic, s1 != s2 1
CLOSED: [2023-11-13 lun. 17:18]
Basic use of the function, s1 and s2 differs (s1 < s2) and n = len(s1).
Return value: negative (s1[i] - s2[i]).
*** CODED Basic, s1 != s2 2
CLOSED: [2023-11-13 lun. 17:18]
Basic use of the function, s1 and s2 differs (s1 > s2) and n = len(s1).
Return value: positive (s1[i] - s2[i]).
*** CODED byte zero in both strings
CLOSED: [2023-11-13 lun. 17:20]
Both strings contain multiple '\0' inside and then a byte is different (s1 > s2).
Return value: positive.
*** CODED n = 0
CLOSED: [2023-11-13 lun. 17:20]
n set to zero.
Return value: 0.
*** CODED s1 not unsigned char
CLOSED: [2023-11-13 lun. 17:23]
s1 value set to an integer bigger than unsigned char.
Return value: Same as usual if values are casted to unsigned char.
*** CODED s2 not unsigned char
CLOSED: [2023-11-13 lun. 17:24]
s2 value set to an integer bigger than unsigned char.
Return value: Same as usual if values are casted to unsigned char.
*** CODED NULL s1, n > 0
CLOSED: [2023-11-13 lun. 17:28]
s1 set to NULL and n > 0.
Return value: / (SEGFAULT)
*** CODED NULL s2, n > 0
CLOSED: [2023-11-13 lun. 17:28]
s2 set to NULL and n > 0.
Return value: / (SEGFAULT)
*** CODED NULL s1 & s2, n > 0
CLOSED: [2023-11-13 lun. 17:29]
s1 & s2 set to NULL, n > 0.
Return value: / (SEGFAULT)
*** CODED NULL s1 & s2, n = 0
CLOSED: [2023-11-13 lun. 17:29]
s1 & s2 set to NULL, n = 0.
Return value: 0.
** DONE ft_strnstr [15/15]
#+begin_src C
char    *ft_strnstr(const char *big, const char *little, size_t len);
#+end_src
CLOSED: [2023-11-13 lun. 18:49]
*** CODED Basic inputs
CLOSED: [2023-11-13 lun. 18:30]
string little contained in big and len = len(big).
Return value: pointer to first char of first occurrence of little in big.
*** CODED little not in big
CLOSED: [2023-11-13 lun. 18:31]
string little not contained in big.
Return value: NULL.
*** CODED len = len(little)
CLOSED: [2023-11-13 lun. 19:30]
len set len(little). len is contained in big but only after len.
Return value: NULL.
*** CODED Smaller len
CLOSED: [2023-11-13 lun. 18:32]
little contained in big but after len.
Return value: NULL.
*** CODED Bigger len
CLOSED: [2023-11-13 lun. 18:33]
little not contained in big and len > len(big).
Return value: NULL.
*** CODED len = 0
CLOSED: [2023-11-13 lun. 18:34]
len set to zero.
Return value: NULL.
*** CODED big empty
CLOSED: [2023-11-13 lun. 18:35]
big set to an empty string.
Return value: NULL.
*** CODED little empty
CLOSED: [2023-11-13 lun. 18:36]
little set to an empty string.
Return value: big.
*** CODED big & little empty
CLOSED: [2023-11-13 lun. 18:37]
little & big set to an empty string.
Return value: pointer to big.
*** CODED NULL big, len > 0
CLOSED: [2023-11-13 lun. 18:39]
big set to NULL.
Return value: / (SEGFAULT)
*** CODED NULL big, len = 0
CLOSED: [2023-11-13 lun. 18:40]
big set to NULL.
Return value: NULL.
*** CODED NULL little, len > 0
CLOSED: [2023-11-13 lun. 18:41]
little set to NULL.
Return value: / (SEGFAULT)
*** CODED NULL little, len = 0
CLOSED: [2023-11-13 lun. 18:41]
little set to NULL.
Return value: / (SEGFAULT)
*** CODED NULL big & little, len > 0
CLOSED: [2023-11-13 lun. 18:42]
big & little set to NULL with len > 0.
Return value: / (SEGFAULT)
*** CODED NULL big & little, len = 0
CLOSED: [2023-11-13 lun. 18:42]
big & little set to NULL with len = 0.
Return value: / (SEGFAULT)
** DONE ft_atoi [13/13]
CLOSED: [2023-11-14 Tue 15:50]
#+begin_src C
int ft_atoi(const char *nptr);
#+end_src
*** CODED Basic input
CLOSED: [2023-11-14 Tue 11:03]
Simple number passed.
Return value: integer version of number in nptr.
*** CODED negative integer
CLOSED: [2023-11-14 Tue 11:04]
Negative number passed.
Return value: integer version of number in nptr.
*** CODED Normal number with positive sign
CLOSED: [2023-11-14 Tue 11:05]
Normal number with positive sign before.
Return value: integer version of number in nptr.
*** CODED Multiple signs
CLOSED: [2023-11-14 Tue 11:05]
Normal number with more than one signs before.
Return value: 0.
*** CODED Whitespaces before sign
CLOSED: [2023-11-14 Tue 11:08]
Normal number with multiple whitespaces before sign.
Return value: integer version of number in nptr.
*** CODED Whitespaces after sign
CLOSED: [2023-11-14 Tue 11:08]
Normal number with multiple whitespaces after sign.
Return value: 0.
*** CODED Whitespace in number
CLOSED: [2023-11-14 Tue 11:09]
Normal number with whitespaces after some numbers.
Return value: integer version of number before whitespaces.
*** CODED Int min
CLOSED: [2023-11-14 Tue 11:16]
Minimum integer passed.
Return value: integer version of number in nptr.
*** CODED Int max
CLOSED: [2023-11-14 Tue 11:16]
Maximum integer passed.
Return value: integer version of number in nptr.
*** CODED Greater than int max
CLOSED: [2023-11-14 Tue 11:17]
Number greater than int max passed.
Return value: equivalent value of number converted to int (bits).
*** CODED Greater than unsigned int max
CLOSED: [2023-11-14 Tue 11:18]
Number greater than unsigned int max passed.
Return value: -1
*** CODED Empty nptr
CLOSED: [2023-11-14 Tue 11:19]
nptr set to empty string.
Return value: 0.
*** CODED NULL nptr
CLOSED: [2023-11-14 Tue 11:21]
nptr set to NULL.
Return value: / (SEGFAULT)
** TODO ft_calloc [0/5]
#+begin_src C
void    *ft_calloc(size_t nmemb, size_t size);
#+end_src
*** CODE normal allocation
Try to free memory allocated by ft_calloc with normal inputs.
Behavior: Allocation & initialization of memory.
Return value: pointer to memory.
*** CODE basic
Normal values passed & size of pointer compared to calloc.
Behavior: Allocation & initialization of memory.
Return value: pointer to memory.
*** CODE malloc protection
Make malloc fail.
Behavior: No allocation.
Return value: NULL.
*** CODE zero
nmemb & size set to 0.
Behavior: No allocation.
Return value: NULL.
*** CODE Size too big
Too big size passed to ft_calloc.
Behavior: No allocation.
Return value: NULL.
** TODO ft_strdup [/]
** ft_substr
** ft_strjoin
** ft_strtrim
** ft_split
** ft_itoa
** ft_strmapi
** ft_striteri
** ft_putchar_fd
** ft_putstr_fd
** ft_putendl_fd
** ft_putnbr_fd

* Bonus part
** ft_lstnew
** ft_lstadd_front
** ft_lstsize
** ft_lstlast
** ft_lastadd_back
** ft_lstdelone
** ft_lstclear
** ft_lstiter
** ft_lstmap
